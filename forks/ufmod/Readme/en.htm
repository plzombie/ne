<html><head><meta http-equiv=Content-Type content="text/html; charset=windows-1251"><title>uFMOD</title></head><body style='margin:0'><table border=0 cellpadding=0 cellspacing=0 width=100%><tr bgcolor=#E7E7E7 align=center><td height=20 style='color:#708090;font-size:9pt;font-family:Arial,Aerial'>[ English | <a href='es.htm'>Espa&#241;ol</a> | <a href='ru.htm'>Pycc&#954;u&#250;</a> ]<tr bgcolor=#708090><td height=1></table><center><h2 style='font-size:14pt;font-family:Arial,Aerial'>&#956;FMOD v1.25.2 for Win32</h2></center><div style='font-size:10pt;font-family:Arial,Aerial;text-align:justify;margin:8'><p>uFMOD is an XM player library written in assembly language. It's perfect for size- and speed-critical applications, click free, highly reliable, easy to use, open source, multiplatform. File, resources and direct memory playback supported. It is able to play even damaged and non-standard XM tracks. Usage examples available for the following compilers: Visual C++, C#, Visual Basic, PureBasic, FreeBASIC, BlitzMax, Emergence BASIC, Delphi, Borland C++ Builder, Dev-C++ (MingW), FreePascal, MASM32, FASM, NASM and TASM.<p><ul><li><a href='#1'>WINMM, DirectSound or OpenAL?</a><li><a href='#2'>Tools</a><ul><li><a href='#21'>XMStrip</a><li><a href='#22'>Eff</a></ul><li><a href='#3'>Compiling the library</a><li><a href='#4'>Examples</a><li><a href='#5'>Reducing the executable file size</a><li><a href='#6'>FAQ</a><li><a href='#7'>Thanks</a></ul><p>&nbsp;<br><a name='1'><b>WINMM, DirectSound or OpenAL?</b></a><p>uFMOD for Win32 supports WINMM, DirectX&#174; DirectSound and <a href='http://www.openal.org/'>OpenAL</a>. All three drivers have pros and cons. DirectSound provides sound effects, mixing capabilities and a wide range of advanced features, like 3D sound. It is even considered to be more reliable than WINMM. On the other hand, WINMM is almost always available, even in good old Windows 95. OpenAL is cross-platform (available in Windows, Linux, Macintosh, <a href='http://www.openal.org/platforms.html'>etc</a>.), features hardware accelerated environmental effects, very useful in game development. However, it is not preinstalled in Windows XP and earlier, except in some OEM machines with high-end Creative sound cards. So, you'd probably need to download the redistributable OpenAL drivers prior to starting developing OpenAL-powered applications. Depending on hardware and drivers, WINMM output could sound <i>clearer</i> than DirectSound's or viceversa. However, most users won't tell the difference. If you are not sure which uFMOD version to choose for your project, probably the standard WINMM version whould suit your needs better. At least, it's easier to use: just a couple of lines of source code will do the job.<p>&nbsp;<br><a name='2'><b>Tools</b></a><p>There are 2 freeware tools currently available to use along with uFMOD: XMStrip and Eff. Both utilities have dual interface: console and graphical (GUI). When ran with command line arguments, console mode is triggered. GUI is rather self-explanatory. Next, we'll explain console-based usage.<p><table border=0 cellpadding=0 cellspacing=0 bgcolor=#708090 style='font-size:9pt;font-family:Arial,Aerial'><tr><td colspan=3 height=1><tr height=18><td style='color:#E7E7E7'><b>&nbsp;SVN&nbsp;</b><td bgcolor=#E7E7E7>&nbsp;<a href='http://ufmod.svn.sourceforge.net/viewvc/ufmod/Win32'>Complete source code available</a>&nbsp;<td width=1><tr><td colspan=3 height=1></table><p><a name='21'><b><i>XMStrip</i></b></a> expects an XM filename on input, repacks the file contents to make it smaller, without losing sound quality. What it does exactly is removing overhead data (dummy instruments, patterns and junk metadata), stripping reserved and currently unused bytes, repacking pattern data. Typing <code>xmstrip /h</code> produces the following output:<p><center><table border=0 cellpadding=8><tr bgcolor=#000000><td><pre><font color=#008000> uFMOD XMSTRIP</font><font color=#FFFFFF>
 USAGE:  xmstrip [options] file [output]
         file   - input file name, which can
                  contain wildcards (* and ?)         
                  for batch processing.
         output - optional output file name
 options:
  /c - clean only (don't strip)
 When [output] is not specified, XMSTRIP
 attempts to overwrite the input. If file
 name contains spaces, enclose it in "".</font></table></center><p>Keep in mind, that other XM players whould probably reject a 'stripped' XM file. The <b>/c</b> option is useful for 'recovering' such a stripped file or just cleaning a regular file intended to be played with any other XM player.<p><a name='22'><b><i>Eff</i></b></a> is useful for advanced users, willing to squeeze every single byte out of their applications. The general idea is to extract only those features you do mean to use in your application, recompile the uFMOD library from source and obtain the smallest possible footprint. So, let's start opening the command shell and typing <code>eff /h</code> to request the following prompt:<p><center><table border=0 cellpadding=8><tr bgcolor=#000000><td><pre><font color=#008000> uFMOD XM effects extractor</font><font color=#FFFFFF>
 USAGE:  eff [options] file
         file - input file name
         options:
          /Dm - generate a masm32/tasm dump
          /Dd - generate a Pascal (Delphi) dump
          /Dc - generate a C/C++ dump
          /Ds - generate an RCDATA resource dump
          /Di - disable infoAPI:
                    uFMOD_GetStats, uFMOD_GetRowOrder,
                    uFMOD_GetTitle and uFMOD_GetTime
          /Dp - disable uFMOD_Pause, uFMOD_Resume
                    and XM_SUSPENDED
          /Dv - disable volume control
          /Dj - disable Jump2Pattern
          /Df - disable loading XM from file
          /Dr - disable loading XM from resource
          /Dl - disable XM_NOLOOP
          /M  - mark & clear unused chunks of
                data in a masm32/tasm compatible dump</font></table></center><p>As you can see, the last parameter is expected to be a filename, specifying the XM file you plan to use in your application. Additional options:<ul><li><b>/Dm</b> produces a hex dump from the given XM file, suitable for MASM32 and TASM. Both MASM32 and TASM examples included in the current uFMOD release use such hex dumps instead of regular resources to save some bytes.<li><b>/Dd</b> and <b>/Dc</b> produce hex dumps in Pascal (Delphi, Kylix, FreePascal) or C/C++ format respectively.<li><b>/Ds</b> generates a hex dump in RCDATA format, used in resource scripts. Some resource script compilers don't support the Microsoft's <code>id RCDATA "filename"</code> syntax. An RCDATA hex dump should be used for compatibility with early GNU resource compilers, like the one included in Dev-C++.<li>Specify <b>/Di</b> to disable all the information functions: uFMOD_GetStats, uFMOD_GetRowOrder, uFMOD_GetTitle and uFMOD_GetTime. Removing them reduces the library size and makes it somewhat faster.<li><b>/Dp</b> removes uFMOD_Pause and uFMOD_Resume functions and makes uFMOD ignore the XM_SUSPENDED flag. If you don't plan to use pause/resume features, add this option to the command line and save some more bytes.<li>uFMOD_SetVolume not only makes the library bigger, but also consumes some additional CPU time. Just use <b>/Dv</b> to turn it off and recover some bytes and clock cycles ;)<li><b>/Dj</b> disables the Jump2Pattern feature. This is an advanced feature, not used in most applications. Check the <a href='#5'>"Reducing the executable file size"</a> section for more information on using Jump2Pattern.<li>Not going to play files and/or resources? - An optimization geek uses hex dumps instead of resources anyway! Then, you'd probably like to use <b>/Df</b> and <b>/Dr</b> in order to make the library smaller.<li><b>/Dl</b> (lower-case letter L) makes uFMOD ignore the XM_NOLOOP flag (and makes the library smaller and faster, as expected).<li>Finally, a really insane optimization option is available only for MASM32/TASM coders. There are some byte chunks inside every XM file, which are reserved for future use or just holding metadata (comments, adds and so on). <b>/M</b> marks all such 'holes' in the hex dump and makes them available for something more useful, like storing code and/or data right inside the XM track. Masm32\winmm\ example uses this feature.</ul>On success, Eff produces a file EFF.INC and a hex dump, if requested. Some examples (all correct):<p><b>eff /Dmpvjfrl /M example.xm<br>eff /M /Dm /Dp /Dv /Dj /Df /Dr /Dl example.xm<br>eff -M -Dmpvjfrl example.xm</b><p>The above commands produce a MASM32/TASM dump with all the 'holes' properly outlined and cleared by default. The EFF.INC header contains the XM effects actually used in the given XM file and some additional flags to disable pause/resume, volume control, Jump2Pattern, file and resource support and XM_NOLOOP. Copy EFF.INC to ufmodlib\src\ and recompile the library (check the following section for a quick guide). Enjoy your own extremely optimized uFMOD build, but keep in mind that it contains a subset of XM effects. So, it will play normally only the given XM file!<p>&nbsp;<br><a name='3'><b>Compiling the library</b></a><p>Recompiling the library sources is required after using <a href='#22'>Eff</a> or to enable some special features in a regular build (check the <b>Options</b> table below). Some people might consider modifying the source code of the library just to practice assembly programming or for any other reason. Well, the following information is intended only for those interested in the subject.<p>The complete source code is included in ufmodlib\src\:<ul><li><span style='color:#800080'><b>eff.inc</b></span> is a header file. The <a href='#22'>Eff</a> tool generates this file. Modifying it directly is not recommended.<li><span style='color:#800080'><b>equs.inc</b></span> contains most of the structures and constant definitions.<li><span style='color:#008080'><b>core.asm</b></span> contains most of the uFMOD source code. The exactly same file is used in Win32, Linux, Unix/BSD and KolibriOS packages. Loading an XM track, mixing sound channels, XM effects handling and other common algorithms are all implemented in this file.<li><span style='color:#008080'><b>ufmod.asm</b></span> contains platform-specific implementation: file and resource handling, threading, etc. The contents of this file vary in Win32, Linux, Unix/BSD and KolibriOS.<li><span style='color:#008080'><b>fasm.asm</b></span> contains Flat Assembler (FASM) specific definitions. This stub file makes it possible to compile uFMOD using FASM.<li><span style='color:#008080'><b>masm.asm</b></span> contains MASM32/TASM specific definitions. This stub file makes it possible to compile uFMOD using MASM32 or TASM.<li><span style='color:#008080'><b>nasm.asm</b></span> contains Netwide Assembler (NASM) specific definitions. This stub file makes it possible to compile uFMOD using NASM.<li><span style='color:#000080'><b>ufmod.desc</b></span>, <span style='color:#000080'><b>oalufmod.desc</b></span> and <span style='color:#000080'><b>dsufmod.desc</b></span> are PureBasic library description files. PureBasic Library SDK requires these files to compile uFMOD in PureLibrary format.<li><b>ufmod.def</b>, <b>oalufmod.def</b> and <b>dsufmod.def</b> are DLL definition files. They are used for building uFMOD as DLL.</ul>ufmodlib\import\ contains the source code required to generate all the import libraries used along with uFMOD. Some of them are required for building the uFMOD library for Visual Basic 6 and FreePascal. These are already prebuilt and located in ufmodlib\lib\. DirectSound and OpenAL import libraries for various compilers are also included here. All these libraries are built using the ImpLib SDK, which can be downloaded as a stand-alone project from the following website: <a href='http://implib.sourceforge.net'>implib.sf.net</a>. ufmodlib\import\<b>buildall.bat</b> is a batch file. It recompiles all of the import libreries mentioned above.<p>There's a tool available in ufmodlib\bin\. It is used to make a regular OMF object file compatible with Delphi. It's not as powerful as EliCZ' OMF2D, but smart enough to make a Delphi compatible uFMOD library. When building uFMOD in OMF format with NASM, <b>o4delphi</b> gets involved.<p><table border=0 cellpadding=0 cellspacing=0 bgcolor=#708090 style='font-size:9pt;font-family:Arial,Aerial'><tr><td colspan=3 height=1><tr height=18><td style='color:#E7E7E7'><b>&nbsp;SVN&nbsp;</b><td bgcolor=#E7E7E7>&nbsp;<a href='http://ufmod.svn.sourceforge.net/viewvc/ufmod/Win32'>Complete source code available</a>&nbsp;<td width=1><tr><td colspan=3 height=1></table><p>Once you are done modifying the uFMOD sources, next step is compiling them. Pick one of the batch files located in ufmodlib\ depending on the target compiler you want to build uFMOD for. The following table should help you selecting the proper batch file:<p><table border=0 cellpadding=4 cellspacing=2 style='font-size:10pt;font-family:Arial,Aerial'><tr bgcolor=#708090 style='color:#E7E7E7;font-weight:bold'><td>BAT<td>Target compiler(s)<td>Notes<tr valign=top><td>mk_coff<td>Visual C/C++, Dev-C++ (MingW), <a href='http://www.flatassembler.net/'>FASM</a>, <a href='http://nasm.sourceforge.net/'>NASM</a>, MASM32, <a href='http://sourceforge.net/projects/fbc/'>FreeBASIC</a><td>The most recommended assembler for building uFMOD in COFF format is FASM.<tr bgcolor=#E7E7E7 valign=top><td>mk_omf<td>Borland Delphi, Borland C++ Builder, TASM<td>Borland C++ Builder and TASM users should set UF_FMT option to LIB. Delphi users should set it to OBJ instead.<tr><td>mk_vb6<td>Visual Basic 6<td><tr bgcolor=#E7E7E7><td>mk_pbas<td>PureBasic<td><tr><td>mk_bmax<td>BlitzMax<td><tr bgcolor=#E7E7E7><td>mk_fpas<td><a href='http://sourceforge.net/projects/freepascal/'>FreePascal</a><td><tr><td>mk_ebas<td>Emergence BASIC<td><tr bgcolor=#E7E7E7><td colspan=3 height=2></table><p>Now open the selected batch file in a plain text editor. Everything contained between the following lines:<pre>rem *** CONFIG START</pre>and<pre>rem *** CONFIG END</pre>is configurable. First of all, check the <code>Pathes</code> section. There might be an option saying:<pre>SET UF_MASM=C:\masm32</pre>If you do have MASM32 installed, make sure the above path points exactly to where MASM32 is located. Let's say MASM32 has been installed to <code>D:\TOOLS\MASM32</code>. Then, you'd have to modify the above entry as follows:<pre>SET UF_MASM=D:\TOOLS\MASM32</pre>Not all of the pathes are always used to recompile the libraries. For example, if you prefer using FASM as your default assembler, you don't need to setup the MASM32 path. Some pathes contain filenames as well. For example:<pre>SET UF_ARCH=ar</pre>ar.exe is supposed to be in one of the directories that are listed in the PATH environment variable. If not, you'd have to modify the above entry. Let's say <code>C:\Program files\BlitzMax\bin\ar.exe</code> is the correct path. So, let's modify the UF_ARCH variable:<pre>SET UF_ARCH=C:\Program files\BlitzMax\bin\ar.exe</pre>Make sure all the pathes actually required to build the libraries have been set correctly. Then, procede modifying the available options, according to the following table:<p><table border=0 cellpadding=4 cellspacing=2 style='font-size:10pt;font-family:Arial,Aerial'><tr bgcolor=#708090 style='color:#E7E7E7;font-weight:bold'><td>Option<sup>*</sup><td>Description<td width=200>Values<sup>*</sup><tr valign=top><td>UF_RAMP<td>This option controls the volume ramping (interpolation) mechanism. Ramping is intended to suppress audible clicks, but sometimes it may introduce distortion. STRONG is the default value recommended for most applications. It detects volume changes during sample playback and softens them using a 64 stage linear ramp. WEAK uses 16 linear stages only. It is less effective than STRONG, but distortion is also less likely to happen. NONE doesn't perform ramping at all. No ramping = no distortion, but most XM samples will produce clicks, unless the samples are well balanced enough.<td>NONE, WEAK, STRONG<tr bgcolor=#E7E7E7 valign=top><td>UF_FREQ<td>Mixing rate (in Hz). 44100 was the default value until uFMOD v1.20. 48KHz actually sounds better on most soundcards and uses less system resources. So, 48000 is the new default value recommended for most applications. 22050 is supported just for fun (rememder the Amiga days...)<td>22050, 44100, 48000<tr valign=top><td>UF_UFS<td>Text encoding. Unicode applications should set this to UNICODE, except in BlitzMax, PureBasic and Visual Basic 6, where UNICODE option is not currently supported. Keep in mind that Unicode applications run significantly faster on NT/XP machines. UNICODE is mandatory when recompiling uFMOD for .NET.<td>ANSI, UNICODE<tr bgcolor=#E7E7E7 valign=top><td>UF_FMT<td>Produce a set of static libraries, plain object files or DLLs and import libraries. For example, Delphi doesn't support lib-files, so you should set UF_FMT to OBJ for Delphi compatibility. C/C++ and all of the assembler compilers support both libs and objs. Some compilers don't support static linking at all, so DLL is the only way to go. It defeats the whole point of using XM music though. We've included this option for the sake of completeness only.<td>OBJ, LIB, DLL
<tr valign=top><td>UF_ASM<td>Assembler. Yes, the uFMOD libraries are compilable with various assemblers. Choose your favorite :)<td>MASM, NASM, FASM, TASM<tr bgcolor=#E7E7E7 valign=top><td>UF_MODE<td>NORMAL is the default value. Nothing special. UNSAFE disables checking an XM track for validity at load time. When you are sure all XM tracks are valid (you can use Eff or XMStrip to verify an XM file), you can recompile uFMOD in UNSAFE mode to reduce the file size and maximize the loading speed. Keep in mind that a damaged XM file can actually crash uFMOD while in UNSAFE mode! Recompiling uFMOD in BENCHMARK mode makes available a performance counter, which tells the exact amount of clock cycles used to produce about 21 ms of sound @ 48KHz. This mode is meant to be used for comparing the performance of different uFMOD versions. Check the C examples and the BENCHMARK flag for more info. BENCHMARK mode is available only in C, MASM, FASM, NASM and TASM.<td>NORMAL, UNSAFE, BENCHMARK</table><span style='font-size:8pt'>* Every batch file uses a subset of this options and values.</span><p>Run the batch to build all the available library targets: WINMM, OpenAL and DirectX DirectSound. That's all!<p>&nbsp;<br><a name='4'><b>Examples</b></a><p>Compiler-specific usage examples are provided in separate folders. Every example folder contains WINMM and DirectX projects. OpenAL examples are available for most of the compilers as well. Most representative examples contain prebuild executables to show the smallest image size achieved so far. Prebuilt binaries are neither compressed, nor packed.<p><table border=0 cellpadding=4 cellspacing=2 style='font-size:10pt;font-family:Arial,Aerial'><tr bgcolor=#708090 style='color:#E7E7E7;font-weight:bold'><td>Dir<td width=160>Compiler<td>Contributed by<td>Notes<tr><td>BCB<td>Borland C++ Builder<td><a href='mailto:sfengtfw@gmail.com'>dododo</a><td><tr bgcolor=#E7E7E7 valign=top><td>Delphi<td>Borland Delphi<td>*<td>Delphi 5 - 7 users should compile the examples via the batch files in order to make the executables a bit smaller. Delphi 9 or later users should build both projects from the IDE only, because some compiler internals used in the BATs changed in later versions.<p>Complete and up-to-date DirectSound and OpenAL units for Delphi are available. uFMOD for DirectX DirectSound and OpenAL require these units. You can also use them in stand alone projects.<tr valign=top><td>Fasm<td>Flat Assembler<td>bogrus, *<td>Pure FASM (no linker) and FASM plus MS Linker or Polink examples provided just to show both ways to build an executable using FASM.<tr bgcolor=#E7E7E7 valign=top><td>Masm32<td>MASM32<td>*<td>The most complex uFMOD usage samples. The main idea is to place the executable code and data inside (!) the XM stream to reduce the executable image size. Only for real optimization freaks! RadASM IDE project files included.<tr><td>Nasm<td>Netwide Assembler<td>*<td>Using MS Linker or Polink.<tr bgcolor=#E7E7E7><td>Tasm<td>Borland Turbo Assembler<td>*<td>RadASM IDE project files included.<tr valign=top><td>PureBasic<td>PureBasic<td><a href='http://flaith.free.fr/'>flaith</a>, chris_b<td>PureBasic version 3.50 or later required. Copy the given PureLibraries to [PureBasic]\PureLibraries\UserLibraries before compiling the projects. A helpfile for PureBasic uFMOD API is available in the HELP subfolder. Copy this CHM to [PureBasic]\HELP if you wish to use it from the IDE.<p>The OpenAL example require the PureBasic OpenAL SDK, which can be found at the <a href='http://implib.sourceforge.net/'>ImpLib SDK website</a>.<tr bgcolor=#E7E7E7><td>VisualBasic6<td>Visual Basic 6<td>*<td>Read the <a href='..\Examples\VisualBasic6\Readme\en.txt'>readme file</a> before compiling!<tr valign=top><td>C<td>Visual C/C++, Dev-C++<td>*<td>Minimalistic XM players written in plain C. Load / stop, pause / resume, muting, volume control, playback progress, VU meter, drag&drop and even some DX effects in 15Kb! Both examples support Unicode and the special BENCHMARK mode (requires recompiling the library in BENCHMARK mode first). Tested with Visual C++ 6.0, Visual C++ 2005/2008 Express Edition and Dev-C++ 4.9.9.2.<p>An example showing how to use the Jump2Pattern feature is also available here. It uses a composite XM tracked by Kim (aka norki). For more information on composite XM files and the Jump2Pattern feature, refer to the <a href='#5'>following</a> section.<p>There is a dynamic OpenAL example here as well - it will run even when OpenAL DLL is not found.<tr bgcolor=#E7E7E7 valign=top><td>BlitzMax<td>BlitzMax<td>*, <a href='http://flaith.free.fr/'>flaith</a><td>Complete documentation <a href='..\Examples\BlitzMax\mod\ufmod.mod\ufmod.mod\doc\commands.html'>provided</a>.<p>Complete and up-to-date DirectSound and OpenAL modules for BlitzMax are available. uFMOD for DirectX DirectSound and OpenAL require these modules. You can also use them in stand alone projects.<tr valign=top><td>FreeBASIC<td>FreeBASIC<td>voodooattack, antarman<td>Using a visualization based on Torus by rel. FbEdit IDE project files included.<tr bgcolor=#E7E7E7 valign=top><td>FreePascal<td>FreePascal<td>*<td>Tested with FPC v2.0.4.<p>Complete and up-to-date DirectSound and OpenAL units for FreePascal are available. uFMOD for DirectX DirectSound and OpenAL require these units. You can also use them in stand alone projects.<tr valign=top><td>EBASIC<td>Emergence BASIC<td><a href='http://ts-soft.eu/'>ts-soft</a><td><tr bgcolor=#E7E7E7 valign=top><td>C#<td>.NET SDK<td>*<td>A set of C# examples tested with .NET Framework 2.0. Featuring standalone EXE projects using mixed CLI/C++ code. To make the uFMOD API available in .NET we've made a C++ wrapper to serve as a bridge between managed and unmanaged code. The complete source code is included.</table><span style='font-size:8pt'>* Quantum, Asterix</span><p>&nbsp;<br><a name='5'><b>Reducing the executable file size</b></a><p>Use <a href='#22'>Eff</a> to optimize the library and make it smaller.<p>When embedding the XM track directly into the executable or attaching it as a raw binary resource, it's sometimes worth it trying to optimize the XM itself. Modplug Player features ADPCM compression, which makes the XM somewhat smaller, but it's a lossy compression! Use <a href='#22'>XMStrip</a> for lossless (in terms of sound quality) size optimization.<p>If you're sure all XM tracks your application is going to use are valid (not damaged or otherwise modified), rebuild the library in UNSAFE mode.<p>Try using the undocumented directive <code>/opt:nowin98</code> while linking a Visual C++ or MASM32 project to minimize section alignment. The .rdata section (read-only data, where the IAT and some other constants reside) and .text section (usually contains executable code) could be safely combined together into a single section. Try adding the following directives to MS LINK.EXE or POLINK.EXE command line: <code>/MERGE:.rdata=.text</code><p>There's another MS linker-specific known issue. link.exe attaches some <i>unnecessary</i> data between DOS stub and the beginning of PE header. It's easy to spot the dead weight in a Hex editor - it begins with a magic word 'Rich'. The encoded machine <i>compid</i> follows the magic word. If you don't want your executables being <i>signed</i> this way or just don't like to spend some extra bytes (actually, it's half a Kb!) on the signature, there's a couple of workarounds available. First, you can switch to another linker. Or you can search the web to find an article on patching link.exe. Psst! It's written in russian and available somewhere at wasm.ru.<p>Delphi likes to include a Relocation Table (.reloc section) inside every single executable. That's not required for a typical exe to run (but not a DLL!) and you may safely remove that section. Try using <a href='http://www.jrsoftware.org/striprlc.php'>StripReloc</a> by Jordan Russel, <a href='http://www.uinc.ru/files/index_eng.shtml'>PE Optimizer</a> by Dr. Golova or a similar tool in case you don't know how to remove relocations by hand.<p>Visual Basic and Delphi like to create a Resources section (.rsrc) even if it doesn't contain any useful resources. So, it's usually safe to remove the whole resources section if it doesn't contain forms, XMs or anything your program might really need. The same applies to .flat sections inside PureBasic executables. Be careful while performing this kind of operation on your exe!<p>Packers and exe compressors, such as <a href='http://www.xtreeme.prv.pl/'>FSG</a> and <a href='http://upx.sf.net/'>UPX</a>, make executables smaller. Anyway, to make things fair, the sample executables are not compressed at all!<p>When using MS-COFF import libraries (like kernel32.lib, libkernel32.a, etc.) some space is wasted in the executable image to hold the original thunks tables. These tables are only required when binding the executable image. If you don't plan to bind your executables, you can get rid of the original thunks and save up to 512 bytes or even a couple of kilobytes when importing a large amount of symbols. To do so you should replace the original import libraries, shipped with your compiler SDK (Visual Studio, masm32, etc.) whith modified (stripped) import libraries and rebuild your projects. You can make a "stripped" import library with <a href='http://implib.sourceforge.net/'>ImpLib SDK</a>.<p>That's pretty much everything one should know about optimizing an executable file for size. Let's talk some more about optimizing the XM file size:<p>An advanced XM file size optimization method involves merging various XM tracks in a single composite file. Since you can share the instruments in a composite file, the resulting file size could be a lot smaller than the sum of the separate file sizes before merging. Even without sharing the instruments it will be smaller because of the XM file header being declared only once. Let's see an example with 3 XM files:<pre>
<b>File 1 :</b> XM1_HEADER P11 P12 P13     I11 I12
<b>File 2 :</b> XM2_HEADER P21 P22 P23 P24 I21 I22 I23 I24
<b>File 3 :</b> XM3_HEADER P31             I31
</pre><i><b>Legend:</b> XMn_HEADER is the header of the n-th XM file. Pni is the i-th pattern of the n-th XM file. Ini is the i-th instrument of the n-th XM file.</i><p>First, let's merge them in a single file without sharing the instruments:<pre>
<b>File 4 :</b> XM4_HEADER P11 P12 P13 P21 P22 P23 P24 P31 I11 I12 I21 I22 I23 I24 I31
</pre>Now, let's say I12 is very similar or even equal to I23 and I24 is the same as I31. So, we can modify P2n to make them use I12 instead of I23 and P31 to use I24, so that we can remove I23 and I31:<pre>
<b>File 4 :</b> XM4_HEADER P11 P12 P13 P21 P22 P23 P24 P31 I11 I12 I21 I22 I24
</pre>You'll have to modify the looping and pattern jumping commands and the references to instruments in "files" 2 and 3. Obviously, you can merge just 2 files or more than 3. XM file format limits the amount of patterns and instruments in a single file. That's the general idea. You'd have to learn how to use a tracker in order to perform this kind of optimization. Once you've got all your files merged, you can issue a single uFMOD_PlaySong function call and trigger all the "files" with uFMOD_Jump2Pattern. For example, uFMOD_Jump2Pattern(3) will start playing the 2nd "file", uFMOD_Jump2Pattern(7) will launch the 3rd and uFMOD_Jump2Pattern(0) will reset to the first "file". The exact indexes depend on your pattern layout. C\WINMM\ contains a practical example.<p>Using Jump2Pattern has another advantage: switching is done much faster (practically in no time), as opposed to stopping and reloading a track. So, you can use this feature when quickly switching the background music is required.<p>&nbsp;<br><a name='6'><b>FAQ</b></a><p><span style='color:#008080'><b>Q:</b> Is uFMOD free for any type of use? Even commercial?</span><br><b>A:</b> Yes, currently it is.<p><span style='color:#008080'><b>Q:</b> Where can I get XM files from?</span><br><b>A:</b> Try visiting <a href='http://modarchive.org/'>The Mod Archive</a>. They have a huge archive of free tracker music in XM, IT, S3M and MOD format. You can use <a href='http://www.modplug.com/'>Open Modplug Tracker</a> to convert IT, S3M and MOD tracks to XM format without apparent degradation. There are many talented composers out there in the web sharing their music at no cost. Just don't forget the copyright!<p><span style='color:#008080'><b>Q:</b> Is uFMOD related in some way to Firelight Technologies&#174; FMOD and miniFMOD sound libraries?</span><br><b>A:</b> Not any more. Up until 2004 uFMOD was based on the latest miniFMOD public source code release. Since then, library sources had been completely rewritten, introducing many new features. So, uFMOD is in no way representative of FMOD and miniFMOD sources.<p><span style='color:#008080'><b>Q:</b> Some XM player libraries claim to add only N kilobytes to the executable file. How many Kb does uFMOD add exactly to the executable's size?</span><br><b>A:</b> It is impossible to tell an exact value, because it depends on library features used (especially, when using the Eff utility), test program code layout, XM file size (when embedding the XM into the EXE). It also depends on the linker options. For example, MASM32\minimal.exe is 5.632 bytes without compression, PE format hacking or any other dirty size optimization tricks.<p><span style='color:#008080'><b>Q:</b> Where can I get the official XM file format specification from?</span><br><b>A:</b> No official and up to date specification exists. However, you can take a look at <a href='http://sourceforge.net/project/showfiles.php?group_id=158498&package_id=234625'>"The Unofficial XM File Format Specification: FastTracker II, ADPCM and Stripped Module Subformats"</a>. This document covers most aspects of the original XM file format and all the non-standard extensions currently supported by uFMOD. ModePlug's public source code (it's C++) also serves as reference material on module file formats.<p>&nbsp;<br><a name='7'><b>Thanks go out to</b></a><p>antarman, Barracuda, bogrus, chris_b, cresta, dododo, flaith, Four-F, GL#0M, norki, q_q, SofT MANiAC, S_T_A_S_, ts-soft, voodooattack and yoxola for reporting bugs, requesting interesting features, submitting usage examples and otherwise helping us improve uFMOD.<p><a href='http://wasm.ru'>[WASM.RU]</a> and <a href='http://sf.net'>SourceForge.net</a> for support and hosting.<p>&nbsp;<br><b>Copyright</b><p>uFMOD sources, binaries and utility programs &#169; 2005 - 2008 Asterix and Quantum.<br>All rights reserved.<p>Sample tunes:<ul><li>Minimal III &#169; 2006 - 2008 SofT MANiAC (CoolPHat).<li>BlitzXMK.XM from Jump2Pat example &#169; 2007 - 2008 Kim (aka norki).</ul></div><table border=0 cellpadding=0 cellspacing=0 width=100%><tr bgcolor=#708090><td height=1><tr bgcolor=#E7E7E7><td height=52 style='color:#708090;font-size:10pt;font-family:Arial,Aerial' align=center>Found a bug? Got a question or a suggestion?<br>Starting to develop a cool application using uFMOD? Please, let us know: <a href='mailto:ufmod@users.sf.net'>ufmod@users.sf.net</a></table></body></html>